#!/bin/bash

# -----------------------------------------------------------------------------
# Drupal Interactive Update Helper
#
# Description:
#   Checks for outdated direct Composer dependencies in a Drupal project,
#   creates a dated update branch, then interactively asks the user whether
#   to update each package one by one. Skips packages listed in a ignore file.
#   Commits each successful update individually (including code changes).
#   Finally, asks whether to push the update branch.
#
# Prerequisites:
#   - bash (v4+ recommended)
#   - git
#   - composer (v1 or v2)
#   - jq (command-line JSON processor)
#   - Must be run from the project root directory.
#   - Requires an interactive terminal (TTY), especially if run via Docker.
#     (Use `docker exec -it ...` or `docker compose exec -it ...`)
#
# Configuration File:
#   Create a file named '.drupal-updater-ignore' in the project root.
#   List vendor/package names to skip, one per line.
#   Lines starting with # and empty lines are ignored.
#
# Usage:
#   From project root: vendor/bin/drupal-update-helper
# -----------------------------------------------------------------------------

# --- Configuration ---
readonly CONFIG_FILE=".drupal-updater-ignore"
readonly BRANCH_PREFIX="update"
readonly REMOTE_NAME="origin"
# --- End Configuration ---

# --- Global Variables ---
PINNED_PACKAGES=()
CURRENT_BRANCH=""
UPDATES_PERFORMED=0
update_branch=""

# --- Helper Functions ---

check_command() {
    local cmd=$1
    if ! command -v "$cmd" &> /dev/null; then
        echo "Error: Required command '$cmd' not found. Please install it." >&2
        exit 1
    fi
}

load_pinned_packages() {
    PINNED_PACKAGES=()
    if [[ -f "$CONFIG_FILE" ]]; then
        echo "Loading pinned packages from '$CONFIG_FILE'..."
        while IFS= read -r line || [[ -n "$line" ]]; do
            local pkg_line="${line%%#*}"
            pkg_line="${pkg_line#"${pkg_line%%[![:space:]]*}"}"
            pkg_line="${pkg_line%"${pkg_line##*[![:space:]]}"}"
            if [[ -n "$pkg_line" ]]; then
                PINNED_PACKAGES+=("$pkg_line")
            fi
        done < "$CONFIG_FILE"
        if (( ${#PINNED_PACKAGES[@]} == 0 )); then
             echo "Info: '$CONFIG_FILE' exists but contains no valid package names."
        fi
    else
        echo "Info: Config file '$CONFIG_FILE' not found. No packages will be automatically pinned."
    fi
}

is_pinned() {
    local package_name=$1
    local pinned
    for pinned in "${PINNED_PACKAGES[@]}"; do
        if [[ "$pinned" == "$package_name" ]]; then
            return 0 # True (is pinned)
        fi
    done
    return 1 # False (is not pinned)
}

handle_push_prompt() {
    echo "$UPDATES_PERFORMED update(s) committed to branch '$update_branch'."
    local push_confirm
    read -r -p "Do you want to push the branch '$update_branch' to remote '$REMOTE_NAME'? (y/N): " push_confirm < /dev/tty
    if [[ "$push_confirm" =~ ^[Yy]$ ]]; then
        echo "Pushing branch..."
        if ! git push -u "$REMOTE_NAME" "$update_branch"; then
            echo "Error: 'git push' failed." >&2
        else
            echo "Branch pushed successfully."
        fi
    else
        echo "Branch not pushed."
    fi
}

handle_no_updates() {
     echo "No updates were performed or committed."
     local switch_back_confirm
     read -r -p "Switch back to the original branch '$CURRENT_BRANCH'? (Y/n): " switch_back_confirm < /dev/tty
     if [[ ! "$switch_back_confirm" =~ ^[Nn]$ ]]; then
        if ! git checkout "$CURRENT_BRANCH"; then
             echo "Warning: Failed to switch back to branch '$CURRENT_BRANCH'." >&2
        else
             echo "Switched back to branch '$CURRENT_BRANCH'."
        fi
     fi
}

# --- Main Script Logic ---
main() {
    # --- Sanity Checks ---
    check_command "git"
    check_command "composer"
    check_command "jq"

    if ! git diff --quiet HEAD --; then
        echo "Error: Your working directory has uncommitted changes." >&2
        echo "Please commit or stash them before running this script." >&2
        exit 1
    fi

    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [[ -z "$CURRENT_BRANCH" ]]; then
       echo "Error: Could not determine current git branch." >&2
       exit 1
    fi
    echo "Current branch is: $CURRENT_BRANCH"

    # --- Load Config ---
    load_pinned_packages

    # --- Get Outdated Direct Dependencies ---
    echo "Checking for outdated direct dependencies..."
    local outdated_json
    if ! outdated_json=$(composer outdated -D --no-dev --format=json); then
        echo "Error: 'composer outdated' command failed." >&2
        exit 1
    fi

    local outdated_packages
    if ! outdated_packages=$(echo "$outdated_json" | jq -c '.installed[] | select(.name)'); then
         echo "Error: Failed to parse composer output with jq." >&2
         exit 1
    fi

    if [[ -z "$outdated_packages" ]]; then
        echo "No outdated direct dependencies found. Exiting."
        exit 0
    fi
    echo "Found outdated packages."

    # --- Create Update Branch ---
    local date_stamp
    # Uses current system date for branch name
    date_stamp=$(date '+%Y-%m-%d')
    update_branch="${BRANCH_PREFIX}/${date_stamp}"

    if git rev-parse --verify "$update_branch" &> /dev/null; then
        echo "Branch '$update_branch' already exists."
        local switch_branch_confirm
        read -r -p "Do you want to switch to it and continue? (y/N): " switch_branch_confirm < /dev/tty
        if [[ ! "$switch_branch_confirm" =~ ^[Yy]$ ]]; then
            echo "Aborting."
            exit 1
        fi
        if ! git checkout "$update_branch"; then
           echo "Error switching to branch '$update_branch'. Aborting." >&2
           exit 1
        fi
    else
        echo "Creating and switching to branch '$update_branch'..."
        if ! git checkout -b "$update_branch"; then
           echo "Error creating branch '$update_branch'. Aborting." >&2
           git checkout "$CURRENT_BRANCH" &> /dev/null
           exit 1
        fi
    fi
    echo "Switched to branch '$update_branch'."

    # --- Loop Through Updates (Using Process Substitution) ---
    echo # Blank line
    echo "----- Processing Updates -----"
    UPDATES_PERFORMED=0 # Reset counter just before loop
    while IFS= read -r line; do
        local package_name current_version latest_version
        package_name=$(echo "$line" | jq -r '.name // empty')
        current_version=$(echo "$line" | jq -r '.version // empty')
        latest_version=$(echo "$line" | jq -r '.latest // empty')

        if [[ -z "$package_name" || -z "$latest_version" ]]; then
             echo "Warning: Skipping malformed line from composer output: $line" >&2
             continue
        fi

        echo # Blank line for spacing
        echo "Package:         ${package_name}"
        echo "Current version: ${current_version}"
        echo "Available:       ${latest_version}"

        if is_pinned "$package_name"; then
            echo "Status:          Pinned (ignored)."
            continue
        fi

        local confirm_update
        # Explicitly read from the terminal device
        read -r -p "Do you want to update this package? (y/N): " confirm_update < /dev/tty

        if [[ ! "$confirm_update" =~ ^[Yy]$ ]]; then
            echo "Status:          Skipped by user."
            continue
        fi

        # --- Perform Update ---
        echo "Attempting update..."
        if ! composer update "$package_name" --with-dependencies --no-scripts --no-dev; then
            local update_exit_code=$?
            echo "Error: Composer update failed for ${package_name} (Exit code: ${update_exit_code})." >&2
            echo "Attempting to revert changes to composer.json and composer.lock..."
            if ! git checkout -- composer.json composer.lock; then
                 echo "Warning: Failed to automatically revert composer configuration files." >&2
            else
                 echo "Reverted composer.json and composer.lock."
            fi
            echo "Skipping commit for this package."
            continue
        fi

        # --- If we reached here, composer update succeeded ---
        echo "Update successful for ${package_name}."

        local package_path
        if ! package_path=$(composer show --path "$package_name" 2>/dev/null); then
            echo "Warning: Could not determine installation path for '$package_name'. Code changes might not be committed." >&2
            package_path=""
        elif [[ -z "$package_path" ]]; then
             echo "Warning: Composer returned an empty installation path for '$package_name'. Code changes might not be committed." >&2
             package_path=""
        else
             package_path="${package_path#"${package_path%%[![:space:]]*}"}"
             package_path="${package_path%"${package_path##*[![:space:]]}"}"
        fi

        local files_to_add=("composer.json" "composer.lock")
        if [[ -n "$package_path" && -e "$package_path" ]]; then
            files_to_add+=("$package_path")
        elif [[ -n "$package_path" ]]; then
             echo "Warning: Determined path '$package_path' for '$package_name' does not exist. Not staging this path." >&2
        fi

        if ! git add "${files_to_add[@]}"; then
            echo "Error: 'git add' failed for updated files. Manual intervention needed." >&2
            echo "Skipping commit for this package due to staging issues."
            continue
        fi

        local commit_msg="Update ${package_name} to ${latest_version}"
        if ! git commit -m "$commit_msg"; then
            echo "Error: 'git commit' failed. Manual intervention may be needed." >&2
            echo "Attempting to unstage changes..."
            git reset HEAD -- "${files_to_add[@]}" &> /dev/null
            continue
        else
            echo "Committed: ${commit_msg}"
            UPDATES_PERFORMED=$((UPDATES_PERFORMED + 1))
        fi
        echo "-----------------------------"

    done < <(echo "$outdated_packages") # Feed loop using Process Substitution

    echo # Blank line
    echo "----- Update Summary -----"

    # --- Push Branch or Handle No Updates ---
    if [[ $UPDATES_PERFORMED -gt 0 ]]; then
        handle_push_prompt
    else
        handle_no_updates
    fi

    echo # Blank line
    echo "Script finished."
    echo "Remember to run database updates (drush updb) and clear caches (drush cr) on your server after deploying."

    exit 0
}

# --- Run the main function ---
main "$@"