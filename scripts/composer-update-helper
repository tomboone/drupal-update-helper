#!/bin/bash

# -----------------------------------------------------------------------------
# Drupal Interactive Update Helper
#
# Description:
#   Checks for outdated direct Composer dependencies in a Drupal project,
#   creates a dated update branch, then interactively asks the user whether
#   to update each package one by one. Skips packages listed in a ignore file.
#   Commits each successful update individually (including code changes).
#   Finally, asks whether to push the update branch.
#
# Prerequisites:
#   - bash (v4+ recommended)
#   - git
#   - composer (v1 or v2)
#   - jq (command-line JSON processor)
#   - Must be run from the project root directory.
#   - Requires an interactive terminal (TTY), especially if run via Docker.
#     (Use `docker exec -it ...` or `docker compose exec -it ...`)
#
# Configuration File:
#   Create a file named '.drupal-updater-ignore' in the project root.
#   List vendor/package names to skip, one per line.
#   Lines starting with # and empty lines are ignored.
#
# Usage:
#   From project root: vendor/bin/composer-update-helper
# -----------------------------------------------------------------------------

# --- Configuration ---
readonly CONFIG_FILE=".drupal-updater-ignore"
readonly BRANCH_PREFIX="update"
readonly REMOTE_NAME="origin"
# --- End Configuration ---

# --- Global Variables ---
PINNED_PACKAGES=()
CURRENT_BRANCH=""
UPDATES_PERFORMED=0
update_branch=""

# --- Helper Functions ---

check_command() {
    local cmd=$1
    if ! command -v "$cmd" &> /dev/null; then
        echo "Error: Required command '$cmd' not found. Please install it." >&2
        exit 1
    fi
}

load_pinned_packages() {
    PINNED_PACKAGES=()
    if [[ -f "$CONFIG_FILE" ]]; then
        echo "Loading pinned packages from '$CONFIG_FILE'..."
        while IFS= read -r line || [[ -n "$line" ]]; do
            local pkg_line="${line%%#*}"
            pkg_line="${pkg_line#"${pkg_line%%[![:space:]]*}"}"
            pkg_line="${pkg_line%"${pkg_line##*[![:space:]]}"}"
            if [[ -n "$pkg_line" ]]; then
                PINNED_PACKAGES+=("$pkg_line")
            fi
        done < "$CONFIG_FILE"
        if (( ${#PINNED_PACKAGES[@]} == 0 )); then
             echo "Info: '$CONFIG_FILE' exists but contains no valid package names."
        fi
    else
        echo "Info: Config file '$CONFIG_FILE' not found. No packages will be automatically pinned."
    fi
}

is_pinned() {
    local package_name=$1
    local pinned
    for pinned in "${PINNED_PACKAGES[@]}"; do
        if [[ "$pinned" == "$package_name" ]]; then
            return 0 # True (is pinned)
        fi
    done
    return 1 # False (is not pinned)
}

handle_push_prompt() {
    echo "$UPDATES_PERFORMED update(s) committed to branch '$update_branch'."
    local push_confirm
    read -r -p "Do you want to push the branch '$update_branch' to remote '$REMOTE_NAME'? (y/N): " push_confirm < /dev/tty
    if [[ "$push_confirm" =~ ^[Yy]$ ]]; then
        echo "Pushing branch..."
        if ! git push -u "$REMOTE_NAME" "$update_branch"; then
            echo "Error: 'git push' failed." >&2
        else
            echo "Branch pushed successfully."
        fi
    else
        echo "Branch not pushed."
    fi
}

handle_no_updates() {
     echo "No updates were performed or committed."
     local switch_back_confirm
     read -r -p "Switch back to the original branch '$CURRENT_BRANCH'? (Y/n): " switch_back_confirm < /dev/tty
     if [[ ! "$switch_back_confirm" =~ ^[Nn]$ ]]; then
        if ! git checkout "$CURRENT_BRANCH"; then
             echo "Warning: Failed to switch back to branch '$CURRENT_BRANCH'." >&2
        else
             echo "Switched back to branch '$CURRENT_BRANCH'."
        fi
     fi
}

# --- Main Script Logic ---
main() {
    # --- Sanity Checks ---
    check_command "git"
    check_command "composer"
    check_command "jq"

    if ! git diff --quiet HEAD --; then
        echo "Error: Your working directory has uncommitted changes." >&2
        echo "Please commit or stash them before running this script." >&2
        exit 1
    fi

    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [[ -z "$CURRENT_BRANCH" ]]; then
       echo "Error: Could not determine current git branch." >&2
       exit 1
    fi
    echo "Current branch is: $CURRENT_BRANCH"

    # --- Load Config ---
    load_pinned_packages

    # --- Get Outdated Direct Dependencies ---
    echo "Checking for outdated direct dependencies..."
    local outdated_json
    if ! outdated_json=$(composer outdated -D --no-dev --format=json); then
        echo "Error: 'composer outdated' command failed." >&2
        exit 1
    fi

    local outdated_packages
    if ! outdated_packages=$(echo "$outdated_json" | jq -c '.installed[] | select(.name)'); then
         echo "Error: Failed to parse composer output with jq." >&2
         exit 1
    fi

    if [[ -z "$outdated_packages" ]]; then
        echo "No outdated direct dependencies found. Exiting."
        exit 0
    fi
    echo "Found outdated packages."

    # --- Create Update Branch ---
    local date_stamp
    # Uses current system date for branch name
    date_stamp=$(date '+%Y-%m-%d')
    update_branch="${BRANCH_PREFIX}/${date_stamp}"

    if git rev-parse --verify "$update_branch" &> /dev/null; then
        echo "Branch '$update_branch' already exists."
        local switch_branch_confirm
        read -r -p "Do you want to switch to it and continue? (y/N): " switch_branch_confirm < /dev/tty
        if [[ ! "$switch_branch_confirm" =~ ^[Yy]$ ]]; then
            echo "Aborting."
            exit 1
        fi
        if ! git checkout "$update_branch"; then
           echo "Error switching to branch '$update_branch'. Aborting." >&2
           exit 1
        fi
    else
        echo "Creating and switching to branch '$update_branch'..."
        if ! git checkout -b "$update_branch"; then
           echo "Error creating branch '$update_branch'. Aborting." >&2
           git checkout "$CURRENT_BRANCH" &> /dev/null
           exit 1
        fi
    fi
    echo "Switched to branch '$update_branch'."

    local -a MAJOR_UPDATES_AVAILABLE=() # Declare array to hold report strings

    # --- Loop Through Updates (Using Process Substitution) ---
    echo # Blank line
    echo "----- Processing Updates -----"
    UPDATES_PERFORMED=0 # Reset counter just before loop
    while IFS= read -r line; do
        local package_name current_version latest_version
        package_name=$(echo "$line" | jq -r '.name // empty')
        current_version=$(echo "$line" | jq -r '.version // empty')
        latest_version=$(echo "$line" | jq -r '.latest // empty')

        if [[ -z "$package_name" || -z "$latest_version" ]]; then
             echo "Warning: Skipping malformed line from composer output: $line" >&2
             continue
        fi

        echo # Blank line for spacing
        echo "Package:         ${package_name}"
        echo "Current version: ${current_version}"
        echo "Available:       ${latest_version}"

        # --- Detect Major Version Updates ---
        # Simple major version extraction (remove v, take first number before . or -)
        # Handles versions like v1.2.3, 10.4.5, 2.0.0-beta9 etc.
        # Might not work well for 'dev-master' or complex non-numeric prefixes
        local current_major latest_major
        current_major=$(echo "$current_version" | sed -e 's/^[vV]*//' -e 's/[.-].*//')
        latest_major=$(echo "$latest_version" | sed -e 's/^[vV]*//' -e 's/[.-].*//')

        # Check if both look like numbers and latest > current
        if [[ "$current_major" =~ ^[0-9]+$ && "$latest_major" =~ ^[0-9]+$ && $latest_major -gt $current_major ]]; then
            # Store package info for the report
            MAJOR_UPDATES_AVAILABLE+=("${package_name} (${current_version} -> ${latest_version})")
        fi
        # --- End Major Version Detection ---

        if is_pinned "$package_name"; then
            echo "Status:          Pinned (ignored)."
            continue
        fi

        local confirm_update
        # Explicitly read from the terminal device
        read -r -p "Do you want to update this package? (y/N): " confirm_update < /dev/tty

        if [[ ! "$confirm_update" =~ ^[Yy]$ ]]; then
            echo "Status:          Skipped by user."
            continue
        fi

        # --- Perform Update ---
        echo "Attempting update..."
        # Capture stderr to check for specific errors
        local composer_stderr
        # We need to run the command and capture stderr, while still checking exit code
        # Using process substitution and temporary file for stderr capture
        local stderr_file
        # Use mktemp securely, exit loop iteration if it fails
        stderr_file=$(mktemp) || { echo "Error: Cannot create temp file for stderr capture" >&2; continue; }

        # Execute composer update, redirect stderr to temp file, check exit code directly
        if ! composer update "$package_name" --with-dependencies --no-scripts --no-dev 2> "$stderr_file"; then
            local update_exit_code=$?
            # Ensure stderr file is read even if it's empty, then remove it
            composer_stderr=$(<"$stderr_file")
            rm "$stderr_file" # Clean up temp file

            echo "Error: Composer update failed for ${package_name} (Exit code: ${update_exit_code})." >&2

            # --- Check for specific "missing .git" error ---
            local renamed_git_dir_name=".git_" # Using the corrected name
            local package_install_path # We need the path again here

            # Attempt to get the path robustly
            package_install_path=$(composer show --path "$package_name" 2>/dev/null | awk '{print $NF}')
            package_install_path="${package_install_path#"${package_install_path%%[![:space:]]*}"}" # Trim leading
            package_install_path="${package_install_path%"${package_install_path##*[![:space:]]}"}"  # Trim trailing

            # Check error message AND if the renamed directory exists in the determined path
            if [[ "$composer_stderr" == *"The .git directory is missing"* && -n "$package_install_path" && -d "$package_install_path/$renamed_git_dir_name" ]]; then
                 # Specific error related to renamed .git_ detected
                 echo "------------------------------------------------------------------" >&2
                 echo "Detected 'missing .git' error, likely due to renamed '${renamed_git_dir_name}' directory." >&2
                 echo "This often requires a clean reinstall of the package." >&2
                 echo "To fix this specific package ($package_name), please manually:" >&2
                 # --- MODIFIED INSTRUCTIONS ---
                 echo "  1. Ensure you are in your project root in the correct environment (native shell, Docker container, etc.)." >&2
                 echo "  2. Remove the current package directory:" >&2
                 echo "     rm -rf \"$package_install_path\"" >&2
                 echo "  3. Reinstall dependencies using Composer (GitHub auth might be required):" >&2
                 echo "     composer install" >&2
                 # --- END MODIFIED INSTRUCTIONS ---
                 echo "  4. Then, re-run this update script if needed." >&2
                 echo "------------------------------------------------------------------" >&2
            else
                # Generic failure message (print captured stderr for other errors)
                echo "Composer error output:" >&2
                # Check if stderr is empty before printing
                if [[ -n "$composer_stderr" ]]; then
                    echo "$composer_stderr" >&2
                else
                    echo "(No specific error output captured from Composer)" >&2
                fi

                # Attempt standard revert for other errors
                echo "Attempting to revert changes to composer.json and composer.lock..."
                if ! git checkout -- composer.json composer.lock; then
                     echo "Warning: Failed to automatically revert composer configuration files." >&2
                else
                     echo "Reverted composer.json and composer.lock."
                fi
            fi
            echo "Skipping commit for this package."
            continue # Move to the next package
        else
            # Composer update succeeded (no error)
            rm "$stderr_file" # Clean up temp file on success too
        fi
        # --- END Perform Update ---
        # --- If we reached here, composer update succeeded ---
        echo "Update successful for ${package_name}."

        # --- Get the installation path of the updated package ---
        local package_path
        local raw_path_output
        # Use composer show --path to find where the package lives
        if ! raw_path_output=$(composer show --path "$package_name" 2>/dev/null); then
            echo "Warning: Could not determine installation path for '$package_name' using 'composer show --path'. Code changes might not be committed." >&2
            package_path="" # Ensure variable is empty if command failed
        elif [[ -z "$raw_path_output" ]]; then
             echo "Warning: Composer returned an empty installation path for '$package_name'. Code changes might not be committed." >&2
             package_path="" # Ensure variable is empty
        else
             # Attempt to extract the last field (path) in case composer outputs name + path
             package_path=$(echo "$raw_path_output" | awk '{print $NF}')
             # Trim potential whitespace again
             package_path="${package_path#"${package_path%%[![:space:]]*}"}"
             package_path="${package_path%"${package_path##*[![:space:]]}"}"
             # echo "DEBUG: Raw path output: '$raw_path_output'. Extracted path: '$package_path'" # Optional debug
        fi
        # --- END Get Path ---

        local files_to_add=("composer.json" "composer.lock")
        if [[ -n "$package_path" && -e "$package_path" ]]; then
            files_to_add+=("$package_path")
        elif [[ -n "$package_path" ]]; then
             echo "Warning: Determined path '$package_path' for '$package_name' does not exist. Not staging this path." >&2
        fi

        if ! git add "${files_to_add[@]}"; then
            echo "Error: 'git add' failed for updated files. Manual intervention needed." >&2
            echo "Skipping commit for this package due to staging issues."
            continue
        fi

        # --- Check if anything was actually staged ---
        # Use --quiet to just get exit status, --cached or --staged checks the index
        if git diff --staged --quiet; then
            # Exit code 0 means no differences = nothing staged
            echo "Info: No file changes staged for ${package_name}." # Keep it simple
            echo "      (Update may be blocked by composer.json constraints or package was already up-to-date within constraints)." # EXPLANATION ADDED
            echo "      Skipping commit."
            # We might have added files that existed but had no changes, reset them just in case?
            git reset HEAD -- "${files_to_add[@]}" &> /dev/null # Optional reset
            continue # Skip to next package
        fi
        # --- END Staged Check ---

        local commit_msg="Update ${package_name} to ${latest_version}"
        if ! git commit -m "$commit_msg"; then
            echo "Error: 'git commit' failed. Manual intervention may be needed." >&2
            echo "Attempting to unstage changes..."
            git reset HEAD -- "${files_to_add[@]}" &> /dev/null
            continue
        else
            echo "Committed: ${commit_msg}"
            UPDATES_PERFORMED=$((UPDATES_PERFORMED + 1))
        fi
        echo "-----------------------------"

    done < <(echo "$outdated_packages") # Feed loop using Process Substitution

    echo # Blank line
    echo "----- Update Summary -----"

    # --- Push Branch or Handle No Updates ---
    if [[ $UPDATES_PERFORMED -gt 0 ]]; then
        handle_push_prompt
    else
        handle_no_updates
    fi

    # --- Report Major Updates Available ---
    if (( ${#MAJOR_UPDATES_AVAILABLE[@]} > 0 )); then
        echo # Blank line
        echo "---------------------------------------------"
        echo " Major Version Updates Available Detected: "
        echo "---------------------------------------------"
        echo "The following packages have newer major versions available."
        echo "Upgrading requires manually editing composer.json constraints,"
        echo "running 'composer update [package]' again, and thorough testing:"
        printf " * %s\n" "${MAJOR_UPDATES_AVAILABLE[@]}"
        echo "---------------------------------------------"
    fi
    # --- End Report ---

    echo # Blank line
    echo "Script finished."
    echo "Remember to run database updates (drush updb) and clear caches (drush cr) on your server after deploying."

    exit 0
}

# --- Run the main function ---
main "$@"
